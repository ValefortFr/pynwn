
#  NeverWinter Nights: GFF File Format Reader/Writer
#  [gff.py, v1.2 (BETA), 2004-03-08, jrm]
#
#  ----------------------------------------------------------------------------
#  Copyright (C) 2003-2004 Jordan McCoy. All Rights Reserved.
#
#  This GFF format software is free software; you can use, redistribute, and/or
#  modify it under the terms of the GNU General Public License, as published by
#  the Free Software Foundation, using either version 2 of the license or later
#  available versions.
#
#  THIS GFF FORMAT SOFTWARE IS PROVIDED BY ITS AUTHORS "AS IS", AND ANY EXPRESS
#  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
#  OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT ARE
#  DISCLAIMED. IN NO EVENT SHALL ITS AUTHORS, CONTRIBUTORS OR TESTERS BE LIABLE
#  FOR ANY DIRECT, INDIRECT, INCIDENTIAL, CONSEQUENTIAL OR EXEMPLARY DAMAGES OR
#  CLAIMS HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER CONTRACT, TORT
#  OR STRICT LIABILITY ARISING IN ANY WAY OUT OF THE DISTRIBUTION, MODIFICATION
#  AND/OR OTHER USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
#  DAMAGE. SEE THE GNU GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
#  The GNU General Public License should be available with this distribution as
#  a file named 'LICENSE'; if not, write to the Free Software Foundation, Inc.,
#  59 Temple Place, Suite 300, Boston, MA, 02111-1307 USA. For more information
#  on the terms of this license, please see <http://www.gnu.org/>.
#
#  NeverWinter Nights and all attendent content, as well as the GFF file format
#  remains the copyright of Bioware.


#  USAGE:
#
#  import gff
#  gff_file = gff.gff( 'UTI', 'path\item.uti' )
#  structure = gff_file.structure
#  print gff_file.dump()
#
#  (make modifications to structure)
#
#  gff_file.save()
#
#  (remember, this modifies the blueprint, and so within a module all instances
#   would need to be updated)
#
#  Couple Notes:
#
#    1. This is still BETA software, there may be bugs. I've successfully tested
#       it with a UTI file generated by the toolset; after loading, modifying
#       and saving it from python, the changes showed up without any errors.
#
#    2. The class only loads the specified file when load() is called, or the 
#       first time .structure is accessed; the constructor DOES NOT load the
#       file. Thus, files can be overwritten without reloading a doomed version.
#
#    3. Please send any bug reports, suggestions, etc. to mccoyj@mail.utexas.edu.


import os, struct
import chardet

class gff( object ):
    """Represents a GFF file."""

    # current GFF version
    Version = 'V3.2'

    # gff type ids
    Byte, Char, Word, Short, Dword, Int, Dword64, Int64, Float = 0, 1, 2, 3, 4, 5, 6, 7, 8
    Double, CExoString, ResRef, CExoLocString, Void, Struct, List = 9, 10, 11, 12, 13, 14, 15

    # gff type names
    Types = [
        'byte', 'char', 'word', 'short', 'dword', 'int', 'dword64', 'int64', 'float',
        'double', 'cexostring', 'resref', 'cexolocstring', 'void', 'struct', 'list' ]

    # struct patterns
    HeaderPattern = '4s4s12I'
    StructPattern = '3I'
    LabelPattern  = '16s'
    FieldPattern  = '2I'
    DwordPattern  = 'I'

    def __init__( self, filetype, filename ):
        """Constructor."""

        # associate specified aspects and prepare state
        self.filetype  = filetype
        self.filename  = filename
        self._structure = None

    def getstructure( self ):
        """Gets the structure, loading it if necessary."""

        # load the source file if necessary
        if self._structure is None:
            self.load()

        # return the structure
        return self._structure

    structure = property(
        getstructure,
        None,
        None,
        "The GFF structure." )

    def load( self ):
        """Loads the source of the associated gff file."""

        # attempt to open the gff file and load its header
        self.source = file( self.filename, 'rb' )
        header = struct.unpack( self.HeaderPattern, self.source.read( struct.calcsize( self.HeaderPattern ) ) )
        if header[ 0 ].rstrip() == self.filetype and header[ 1 ] == self.Version:
            self.structoffset, self.structcount = header[ 2:4 ]
            self.fieldoffset, self.fieldcount = header[ 4:6 ]
            self.labeloffset, self.labelcount = header[ 6:8 ]
            self.dataoffset, self.datasize = header[ 8:10 ]
            self.indiceoffset, self.indicesize = header[ 10:12 ]
            self.listoffset, self.listsize = header[ 12:14 ]
        else:
            if header[ 1 ] != self.Version:
                raise ValueError, "gff file version '%s' does not match current valid version '%s'" % ( header[ 1 ], self.Version )
            else:
                raise ValueError, "gff file type '%s' does not match specified file type '%s'" % ( header[ 0 ].rstrip(), self.filetype )

        # position the source file at the struct array and prepare structs list
        self.source.seek( self.structoffset )
        self.structs = []

        # parse the gff struct array
        size = struct.calcsize( self.StructPattern )
        for index in range( 0, self.structcount ):
            type, offset, count = struct.unpack( self.StructPattern, self.source.read( size ) )
            if count == 1:
                self.structs.append( [ type, offset ] )
            else:
                pattern = "%dI" % count
                indexes = struct.unpack( pattern, self.scan( self.indiceoffset + offset, struct.calcsize( pattern ) ) )
                self.structs.append( [ type, list( indexes ) ] )

        # position the source file at the label array and prepare labels list
        self.source.seek( self.labeloffset )
        self.labels = []

        # parse the gff label array
        size = struct.calcsize( self.LabelPattern )
        for index in range( 0, self.labelcount ):
            label = struct.unpack( self.LabelPattern, self.source.read( size ) )[ 0 ]
            self.labels.append( label.rstrip( '\x00' ) )

        # position the source file at the field array and prepare fields list
        self.source.seek( self.fieldoffset )
        self.fields = []

        # parse the gff field array
        size = struct.calcsize( self.FieldPattern )
        dwordsize = struct.calcsize( self.DwordPattern )
        for index in range( 0, self.fieldcount ):
            type, label = struct.unpack( self.FieldPattern, self.source.read( size ) )
            recipe = self.Recipes[ type ]
            if recipe[ 0 ] is True:
                value = self.scan( struct.unpack( self.DwordPattern, self.source.read( dwordsize ) )[ 0 ], recipe[ 2 ] )
                data = struct.unpack( recipe[ 1 ], value )[ 0 ]
            elif recipe[ 0 ] is False:
                data = struct.unpack( recipe[ 1 ], self.source.read( recipe[ 2 ] ) )[ 0 ]
                if recipe[ 2 ] < 4:
                    self.source.seek( self.source.tell() + ( 4 - recipe[ 2 ] ) )
            else:
                offset = struct.unpack( self.DwordPattern, self.source.read( dwordsize ) )[ 0 ]
                data = recipe[ 1 ]( self, offset )
            self.fields.append( [ self.Types[ type ], self.labels[ label ], data ] )

        # close the source file and build the gff structure, then indicate status
        del self.source
        self._structure = self.build_struct( 0 )
        return True

    def save( self ):
        """Saves the current version of the gff structure to the associated file."""

        # prepare the intermediate lists and parse the gff structure into the fields and structs lists
        self.fields, self.labels, self.structs = [], [], []
        self.structs.append( [ 0xFFFFFFFFL, [] ] )
        topfields = self.build_fields( self._structure )
        self.structs[ 0 ][ 1 ] = topfields

        # parse labels out and replace with label indices
        for field in self.fields:
            if field[ 1 ] not in self.labels:
                self.labels.append( field[ 1 ] )
            field[ 1 ] = self.labels.index( field[ 1 ] )

        # generate the structs and field indices arrays
        structs, indices = '', ''
        for structtype, structfields in self.structs:
            if len( structfields ) == 1:
                structs += struct.pack( '3I', structtype, structfields[ 0 ], 1 )
            else:
                structs += struct.pack( '3I', structtype, len( indices ), len( structfields ) )
                for fieldid in structfields:
                    indices += struct.pack( 'I', fieldid )

        # generate the fields, field data and list indices arrays
        fields, fielddata, lists = '', '', ''
        for type, labelidx, data in self.fields:
            fields += struct.pack( '2I', type, labelidx )
            recipe = self.Recipes[ type ]
            if type == self.List:
                fields += struct.pack( 'I', len( lists ) )
                lists += struct.pack( 'I', len( data ) )
                for structid in data:
                    lists += struct.pack( 'I', structid )
            elif type == self.Struct:
                fields += struct.pack( 'I', data )
            elif recipe[ 0 ] is True:
                fields += struct.pack( 'I', len( fielddata ) )
                fielddata += struct.pack( recipe[ 1 ], data )
            elif recipe[ 0 ] is False:
                pattern = recipe[ 1 ]
                if recipe[ 2 ] < 4:
                    pattern += "%dx" % ( 4 - recipe[ 2 ] )
                fields += struct.pack( pattern, data )
            else:
                fields += struct.pack( 'I', len( fielddata ) )
                fielddata += recipe[ 2 ]( self, data )

        # generate the labels array
        labels = ''
        for label in self.labels:
            length = len( label )
            pattern = "%ds" % length
            if length < 16:
                pattern += "%dx" % ( 16 - length )
            labels += struct.pack( pattern, label )

        # generate the header and concat the file content
        content = ''
        header = struct.pack( '8s', "%s %s" % ( self.filetype, self.Version ) )
        header += struct.pack( '2I', 56, len( self.structs ) )
        content += structs
        header += struct.pack( '2I', ( 56 + len( content ) ), len( self.fields ) )
        content += fields
        header += struct.pack( '2I', ( 56 + len( content ) ), len( self.labels ) )
        content += labels
        header += struct.pack( '2I', ( 56 + len( content ) ), len( fielddata ) )
        content += fielddata
        header += struct.pack( '2I', ( 56 + len( content ) ), len( indices ) )
        content += indices
        header += struct.pack( '2I', ( 56 + len( content ) ), len( lists ) )
        content = header + content + lists

        # write the gff file
        target = file( self.filename, 'w+b' )
        target.write( content )
        target.flush()
        target.close()
        return True

    def scan( self, offset, length ):
        """Scans the specified length from the specified offset in the open file, then returns to the previous position."""

        # mark the current position, scan the specified data, and return to the current position
        position = self.source.tell()
        self.source.seek( offset )
        data = self.source.read( length )
        self.source.seek( position )
        return data

    def build_struct( self, sid ):
        """Builds a structural representation of the specified struct id."""

        # assemble the fields of the specified struct
        structure = {}
        for field in self.structs[ sid ][ 1 ]:
            type, label, value = self.fields[ field ]
            if type == 'struct':
                stype, sid = self.structs[ value ]
                structure[ label ] = [ stype, self.build_struct( value ) ]
            elif type == 'list':
                group = []
                for structid in value:
                    stype, sid = self.structs[ structid ]
                    group.append( [ stype, self.build_struct( structid ) ] )
                structure[ label ] = [ 'list', group ]
            else:
                structure[ label ] = [ type, value ]

        # return the completed structure
        return structure

    def build_fields( self, structure ):
        """Build a field list from the specified structure."""

        # identify and parse the fields of the specified structure
        ids = []
        for label, value in structure.iteritems():
            type, data = value
            if type == 'list':
                idlist = []
                for structid, structdata in data:
                    structids = self.build_fields( structdata )
                    self.structs.append( [ structid, structids ] )
                    idlist.append( len( self.structs ) - 1 )
                self.fields.append( [ self.Types.index( 'list' ), label, idlist ] )
                ids.append( len( self.fields ) - 1 )
            elif type in self.Types:
                self.fields.append( [ self.Types.index( type ), label, data ] )
                ids.append( len( self.fields ) - 1 )
            else:
                structid, structdata = data
                structids = self.build_fields( structdata )
                self.structs.append( [ structid, structids ] )
                self.fields.append( [ self.Types.index( 'struct' ), label, len( self.structs ) ] )
                ids.append( len( self.fields ) - 1 )

        # return the field id list
        return ids

    def parse_cexostring( self, offset ):
        """Parses a gff cexostring."""

        # identify the current position, read and parse the cexostring, and return to the current position
        position = self.source.tell()
        self.source.seek( self.dataoffset + offset )
        length = struct.unpack( self.DwordPattern, self.source.read( 4 ) )[ 0 ]
        pattern = "%ds" % length
        data = struct.unpack( pattern, self.source.read( struct.calcsize( pattern ) ) )[ 0 ]
        self.source.seek( position )
        return data

    def write_cexostring( self, data ):
        """Writes the specified data as a cexostring and returns it."""

        length = len( data )
        pattern = "I%ds" % length
        return struct.pack( pattern, length, data )

    def parse_resref( self, offset ):
        """Parses a gff resref."""

        # identify the current position, read and parse the resref, and return to the current position
        position = self.source.tell()
        self.source.seek( self.dataoffset + offset )
        length = struct.unpack( 'B', self.source.read( 1 ) )[ 0 ]
        pattern = "%ds" % length
        data = struct.unpack( pattern, self.source.read( struct.calcsize( pattern ) ) )[ 0 ]
        self.source.seek( position )
        return data

    def write_resref( self, data ):
        """Writes the specified data as a resref and returns it."""

        length = len( data )
        pattern = "B%ds" % length
        return struct.pack( pattern, length, data )

    def parse_cexolocstring( self, offset ):
        """Parses a gff cexolocstring."""

        # identify the current position, read and parse the cexolocstring, and return to the current position
        position = self.source.tell()
        self.source.seek( self.dataoffset + offset )
        length, stringref, count = struct.unpack( '3I', self.source.read( 12 ) )
        result = [ stringref ]
        if count > 0:
            for substring in range( 0, count ):
                id, length = struct.unpack( '2I', self.source.read( 8 ) )
                pattern = "%ds" % length
                data = struct.unpack( pattern, self.source.read( struct.calcsize( pattern ) ) )[ 0 ]
                result.append( [ id, data ] )
        self.source.seek( position )
        return result

    def write_cexolocstring( self, data ):
        """Writes the specified data as a cexolocstring and returns it."""
        if len( data ) == 1:
            return struct.pack( '3I', 8, data[ 0 ], 0 )
        else:
            stringref = data.pop( 0 )
            print data[0][1]
            content = struct.pack( '2I', stringref, len( data ) )
            for substring in data:
                length = len( substring[ 1 ] )
                pattern = "2I%ds" % length
                content += struct.pack( pattern, substring[ 0 ], length, substring[ 1 ] )
            return struct.pack( 'I', len( content ) ) + content

    def parse_void( self, offset ):
        """Parses a gff void."""

        # identify the current position, read and parse the void, and return to the current position
        position = self.source.tell()
        self.source.seek( self.dataoffset + offset )
        length = struct.unpack( self.DwordPattern, self.source.read( 4 ) )[ 0 ]
        data = self.source.read( length )
        self.source.seek( position )
        return data

    def write_void( self, data ):
        """Writes the specified data as a void and returns it."""

        length = len( data )
        pattern = "I%dB" % length
        return struct.pack( pattern, length, data )

    def parse_list( self, offset ):
        """Parses a gff list."""

        # identify the current position, read and parse the list, and return to the current position
        position = self.source.tell()
        self.source.seek( self.listoffset + offset )
        count = struct.unpack( self.DwordPattern, self.source.read( 4 ) )[ 0 ]
        pattern = "%dI" % count
        data = struct.unpack( pattern, self.source.read( struct.calcsize( pattern ) ) )
        self.source.seek( position )
        return data

    def parse_struct( self, offset ):
        """Parses a gff struct."""

        return offset

    # type recipes      ( offset?, pattern, size ) or ( None, function )
    Recipes = {
        Byte:           ( False, 'B', 1 ),
        Char:           ( False, 'c', 1 ),
        Word:           ( False, 'H', 2 ),
        Short:          ( False, 'h', 2 ),
        Dword:          ( False, 'I', 4 ),
        Int:            ( False, 'i', 4 ),
        Dword64:        ( True,  'Q', 8 ),
        Int64:          ( True,  'q', 8 ),
        Float:          ( False, 'f', 4 ),
        Double:         ( True,  'd', 8 ),
        CExoString:     ( None,  parse_cexostring, write_cexostring ),
        ResRef:         ( None,  parse_resref, write_resref ),
        CExoLocString:  ( None,  parse_cexolocstring, write_cexolocstring ),
        Void:           ( None,  parse_void, write_void ),
        Struct:         ( None,  parse_struct, None ),
        List:           ( None,  parse_list, None )
    }

    def dump( self ):
        """Returns a string representation of the gff structure."""

        # ensure structure exists
        if self._structure is None:
            self.load()

        # dump the header
        size = os.stat( self.filename )[ 6 ]
        content = '%s: %s (%d bytes)\n' % ( self.filetype, self.filename, size )
        content += '[%d structs at %d, %d fields at %d, %d labels at %d]\n\n' % ( self.structcount, self.structoffset, self.fieldcount, self.fieldoffset, self.labelcount, self.labeloffset )

        # dump the structure itself
        content += self.dump_struct( self._structure, 0 )

        # return the dumped structure
        return content

    def dump_struct( self, reference, indent ):
        """Dumps a specific struct in the gff structure."""

        # dump the fields and values of the struct
        content = ''
        for label, value in reference.iteritems():
            type, data = value
            if type == 'list':
                content += ( ' ' * indent ) + '%s: [list] %d members...\n' % ( label, len( data ) )
                index = 0
                for item in data:
                    content += ( ' ' * indent ) + ' (%d) => struct %s\n' % ( index, item[ 0 ] )
                    content += self.dump_struct( item[ 1 ], indent + 2 )
                    index += 1
            elif type in self.Types:
                content += ( ' ' * indent ) + '%s: %s  [%s]\n' % ( label, repr( data ), type )
            else:
                content += ( ' ' * indent ) + '%s: [struct] %d...\n' % ( label, data[ 0 ] )
                content += self.dump_struct( data[ 1 ], indent + 2 )

        # return content
        return content
